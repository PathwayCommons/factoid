// the document controller (used to modify a currently-loaded document)

// functions that are exposed to the client side
module.exports = function( model ){

  /* doc schema:

    document: {
      elements: [
        {
          id: "ent1", // ids are actually just unique junk strings generated by derby
          type: "entity", // indicates the type of entity
          name: "some entity" // user specified name
        },

        {
          id: "int1",
          type: "interaction",
          name: "some interaction",
          participantIds: [ "ent1", "ent2" ] // what participants are connected
        }
      ]
    }
  */

  model.on('set', 'entities.*.name', function(id, name, oldName){
    var mEnt = model.at('entities').at(id);
    mEnt.set('changedName', true);
    mEnt.set('_loadingPotentialAssociations', true);

    // update name in participant list
    var ints = model.filter('_entities').where('participantIds').contains( [id] ).get();
    for( var i = 0; i < ints.length; i++ ){
      var parts = ints[i]._participants;

      for( var j = 0; j < parts.length; j++ ){
        var part = parts[j];

        if( part.id === id ){
          model.set('entities.' + ints[i].id + '._participants.' + j + '.name', name);
        }
      }
    }
  });

  function updateParticipantsList( id ){
    var pids = model.get('entities.' + id + '.participantIds');
    var parts = [];

    if( pids ){
      for( var i = 0; i < pids.length; i++ ){
        var pid = pids[i];
        var ent = model.get('entities.' + pid);

        parts.push( ent );
      }
    }

    model.set('entities.' + id + '._participants', parts);
  }

  var ents = model.get('_entities');
  setTimeout(function(){
    for( var i = 0; i < ents.length; i++ ){
      if( ents[i].interaction ){
        updateParticipantsList( ents[i].id );
      }
    }
  }, 100); // b/c derby has some weird race condition where this isn't rendered right on init


  var lastAssociationQueryTime = 0;

  var popoversOpen = false;

  function togglePopover( model, showVar, aniVar, next ){
    popoversOpen = true;
    
    var shown = model.get( showVar );

    if( !shown ){
      doc.closeAllPopovers();

      model.set(showVar, true);

      model.set(aniVar, true);
      setTimeout(function(){
        model.set(aniVar, false);
      }, 500);
    
      next && next( true );
    } else {
      model.set(showVar, false);

      next && next( false );
    }
  }

  function isFunction( obj ){
    return typeof obj === "function";
  }

  function isObject( obj ){
    return typeof obj === 'object';
  }

  function replaceTempIds( ents ){
    var temp2id = {};
    var retEnts = [];

    function getIdFromTemp( temp ){
      var idAlreadyMapped = temp2id[ temp ] != null;
      var id;
      
      if( !idAlreadyMapped ){
        id = temp2id[ temp ] = model.id();
      } else {
        id = temp2id[ temp ];
      }

      return id;
    }

    if( ents ){ for( var i = 0; i < ents.length; i++ ){
      var ent = ents[i];
      var temp = ent.id;
      var id = getIdFromTemp( temp );

      // now, replace the id and put the entity in the return list
      ent.id = id;
      retEnts.push( ent );

      // replace participant ids
      if( ent.participantIds ){
        var pids = ent.participantIds;
        
        for( var j = 0; j < pids.length; j++ ){
          var partTemp = pids[j];
          var partId = getIdFromTemp( partTemp );

          ent.participantIds[j] = partId;
        }
      }
    } } // if & for

    return retEnts;
  };


  // makes sure that we create an entity with all the necessary
  // fields
  function makeEntity( entity ){
    if( !entity ){ // in case nothing specified
      entity = {};
    }

    if( !entity.type ){ // in case type is elided
      entity.type = "entity";
    }

    if( !entity.name ){ // in case name is elided, use some default value
      entity.name = "new entity";
    } else {
      entity.changedName = true;
    }

    entity.entity = true;

    if( !entity.viewport ){
      entity.viewport = {
        x: 0,
        y: 0
      };
    }

    if( entity.id === undefined ){ // then generate an id for the entity
      entity.id = model.id();
    }

    var entityWithSameIdAlreadyExists = doc.entity(entity.id) !== undefined;
    if( entityWithSameIdAlreadyExists ){
      return; // there can only be one
    }

    return entity;
  }

  // makes sure that we create an interaction with all the necessary
  // fields
  function makeInteraction( interaction ){
    interaction = interaction || {}; // ensure we have an object

    if( interaction.type !== "interaction" ){ // enforce interaction type
      interaction.type = "interaction";
    }

    if( !interaction.name ){
      interaction.name = interaction.type;
    }

    if( !interaction.participantIds ){
    interaction.participantIds = [];
    }

    interaction.interaction = true;

    return interaction;
  }

  function makeEntities( ents ){
    if( ents ){ for( var i = 0; i < ents.length; i++ ){

      if( ents[i].type === 'interaction' ){
        ents[i] = makeInteraction( ents[i] );
      } else {
        ents[i] = makeEntity( ents[i] );
      }

    } } // if & for

    return ents;
  }

  return {

    // FUNCTIONS FOR PUBLIC MODELS //
    // stored in the db and synced to clients

    // .addInteraction({ [type], [name] })
    // adds an interaction to the doc
    // NB: you should listen via addEntity (not addInteraction)
    // otherwise, you'd have to negotiate and merge multiple events (pretty hard)
    addInteraction: function( interaction ){
      interaction = makeInteraction( interaction );

      return this.addEntity(interaction);
    },

    // .addEntity({ [type], [name], [viewport] })
    // add an entity to the document
    // 
    // .addEntity( function( entity ){} )
    // listen for when entities are added
    addEntity: function( entity ){
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is added to the doc
        model.on('unshift', '_entities', function(entity){
          fn( entity );
        });
        return;

      } else { // then add the entity to the doc
        entity = makeEntity( entity );
        model.unshift( "_entities", entity );

        doc.populatePotentialParticipantsForAllOpen();

        var mEnt = model.at('entities.' + entity.id);

        mEnt.set('_justAdded', true);
        setTimeout(function(){
          mEnt.set('_justAdded', false);
        }, 250);
      }

      return entity;
    },

    // .removeEntity( entityId )
    // removes the entity from the document
    //
    // .removeEntity( function( entityId ){} )
    // listens for when entities are removed
    removeEntity: function( entityId ){ 
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is removed from the doc
        model.on('remove', '_entities', function(index, howMany, removedIds, isLocal){
          for( var i = 0; i < removedIds.length; i++ ){
            var id = removedIds[i];
            fn(id);
          }
        });
        return;

      } else { // then remove the entity from the doc

        if( model.get('entities.' + entityId + '._showAddParticipants') ){
          popoverIsOpen = false;
        }

        // remove the entity
        var entities = model.get('_entities');
        for( var i = 0; i < entities.length; i++ ){
          var ent = entities[i];

          if( ent.id === entityId ){
            model.remove('_entities', i); // remove from doc
            model.del('entities.' + entityId); // remove from global entities pool
            break;
          }
        }

        var connectedInts = model.filter('_entities').where('participantIds').contains( [entityId] ).get();

        // remove interactions that are hanging from deleting this entity
        for( var i = 0; i < connectedInts.length; i++ ){
          var intn = connectedInts[i];
          var isHanging = intn.participantIds.length === 2;

          if( isHanging ){
            doc.removeEntity( intn.id );
          }
        }

        // remove references to the entity in interactions
        for( var i = 0; i < connectedInts.length; i++ ){
          var inter = connectedInts[i];

          var pids = inter.participantIds;
          for( var j = 0; j < pids.length; j++ ){
            var pid = pids[j];

            if( pid === entityId ){
              model.remove('_entities.' + i + '.participantIds', j);
            }
          }
        }

        doc.populatePotentialParticipantsForAllOpen();
      }
    },

    // removes all entities from the doc
    // NB: use .removeEntity() for listening to when entities are removed
    removeAllEntities: function(){
      var entities = model.get('_entities');
      for( var i = 0; i < entities.length; i++ ){
        var ent = model.get('_entities.' + i);
        
        model.remove('_entities.' + i); // remove from doc
        model.del('entities.' + ent.id); // remove from global entities pool
      }

      var length = model.get('_entities.length');
      model.remove('_entities', 0, length);
    },

    // .connectEntityToInteraction(entId, intId) : connects entity to interaction
    // fails when
    //  - entity and interaction are the same
    //  - entity or interaction aren't in the document
    //  - entity is already connected to interaction
    //  - the interaction specified isn't actually one
    //
    // .connectEntityToInteraction( function(entId, intId){} ) : listens for when
    // an entity is connected to an interaction
    connectEntityToInteraction: function( entityId, interactionId ){
      var intIndex, entIndex, interaction, entity;
      var fn = arguments[0];

      if( isFunction(fn) ){ // then listen to when entities are connected to interactions
        model.on('push', '_entities.*.participantIds', function(intIndex, entityId){
          var interactionId = model.get('_entities.' + intIndex + '.id');
          fn(entityId, interactionId);
        });
        return;
      }

      if( interactionId === entityId ){
        return; // you can't connect an interaction to itself
      }

      var entityExists = this.entityExists( entityId );
      var interactionExists = this.entityExists( interactionId );

      var inDoc = entityExists && interactionExists;
      if( !inDoc ){
        return; // you can't connect them together if they don't exist in the doc
      }
      var interaction = this.entity( interactionId );
      var interactionIsRightType = interaction.interaction;
      if( !interactionIsRightType ){ return; } // can't connect if not right type

      // check if the entity is already connected
      var entityAlreadyConnected = this.interactionHasParticipant( interactionId, entityId );
      if( entityAlreadyConnected ){ return; } // can't connect if already connected

      model.push('entities.' + interactionId + '.participantIds', entityId);

      doc.populatePotentialParticipantsForAllOpen();
      doc.updateParticipantsList( interactionId );

    },

    updateParticipantsList: updateParticipantsList,

    // .disconnectEntityFromInteraction( entId, intId ) : disconnected an entity from an
    // interaction; can fail if they're not connected to begin with
    //
    // .disconnectEntityFromInteraction( function(entId, intId){} ) : listens for when an
    // entity is disconnected from an interaction
    disconnectEntityFromInteraction: function( entityId, interactionId ){
      var fn = arguments[0];

      if( isFunction(fn) ){ // then listen to when entities are disconnected to interactions
        model.on('remove', '_entities.*.participantIds', function(intIndex, index, howMany, removedArray, isLocal){
          var interactionId = model.get('_entities.' + intIndex + '.id');
          for( var i = 0; i < removedArray.length; i++ ){
            var entityId = removedArray[i];

            fn(entityId, interactionId);
          }         
          
        });
        return;
      }

      var entity = this.entity(entityId);
      var interaction = this.entity(interactionId);

      var inDoc = entity && interaction;
      var interactionIsRightType = interaction.interaction;
      if( !inDoc || !interactionIsRightType ){
        return; // you can't connect them together if they don't exist in the doc
      }

      // check if the entity is already connected
      var entityAlreadyConnected = false;
      var pids = interaction.participantIds;
      var entIndex;
      for( var i = 0; i < pids.length; i++ ){
        var pid = pids[i];

        if( pid === entityId ){
          entityAlreadyConnected = true;
          entIndex = i;
          break;
        }
      }

      if( entityAlreadyConnected ){
        model.remove('entities.' + interactionId + '.participantIds', entIndex, 1);

        doc.populatePotentialParticipantsForAllOpen();
        doc.updateParticipantsList( interactionId );
      }
    },

    // .entityName( entId ) : gets the current entity name
    //
    // .entityName( entId, newName ) : sets the entity's name to a new one
    //
    // .entityName( function(entId, name){} ) : listens for when an entity's name is changed
    entityName: function( entityId, name ){
      var fn = arguments[0];

      if( isFunction(fn) ){
        model.on('set', '_entities.*.name', function(index, newName, oldName, isLocal){
          var entityId = model.get('_entities.' + index + '.id');
          fn( entityId, newName );
        });

      } else if( name === undefined ) {
        return model.get('entities.' + entityId + '.name');

      } else {
        var mEntity = model.at('entities').at(entityId);
        mEntity.set('name', name);
        mEntity.set('changedName', true);
      }
    },

    entityHasChangedName: function( entityId ){
      return model.get('entities.' + entityId + '.changedName') ? true : false;
    },

    // NB: the viewport position of the entity is just the model position of the associated node
    // in cytoscape.js but the format could be made more complex to accomodate more info later, if needed
    //
    // .entityViewport( entId ) : gets the current viewport position of the entity
    // 
    // .entityViewport( entId, viewport ) : sets the current viewport position of the entity
    // 
    // .entityViewport( function(entId, viewport){} ) : listens for when an entity's viewport changes
    entityViewport: function( entityId, viewport ){
      var fn = arguments[0];

      if( isFunction(fn) ){
        model.on('set', '_entities.*.viewport', function(index, newPos, oldPos, isLocal){

          if( isLocal ){ return; } // don't trigger if we moved it (since we're already up-to-date)

          if( newPos.x === undefined || newPos.y === undefined ){
            return; // can't really do anything
          }

          var id = model.get('_entities.' + index + '.id');
          fn(id, newPos);
        });

      } else if( viewport === undefined ) {
        return model.get('entities.' + entityId + '.viewport');
      
      } else {
        model.set('entities.' + entityId + '.viewport', viewport);
      }
    },

    // .entity( entId ) : gets the entity with the given id
    // 
    // NB: you shouldn't really need to call this, especially considering that the
    // entity object you get here isn't populated with all the convenient stuff
    // you'd need to build UI, anyway
    entity: function( entityId ){
      return model.get('entities.' + entityId);
    },

    // checks whether an entity with the specified ID exists in the document
    entityExists: function( entityId ){
      return this.entity( entityId ) !== undefined;
    },

    entityIsInteraction: function( entityId ){
      return model.get('entities.' + entityId + '.interaction') ? true : false;
    },
    entityIsAssociated: function( entityId ){
      return model.get('entities.' + entityId + '.association') ? true : false;
    },

    // set/get entity selection state
    entitySelected: function( entityId, selected ){
      if( selected === undefined ){
        return model.get('entities.' + entityId + '._selected') ? true : false;
      } else {
        model.set('entities.' + entityId + '._selected', selected ? true : false);
      }
    },

    // gets all the entities in the document (useful for populating cytoscape.js graph on page load)
    entities: function(){
      return model.get('_entities');
    },

    // gets whether an interaction has a participant
    interactionHasParticipant: function( interactionId, participantId ){

      var partsIds = model.get('entities.' + interactionId + '.participantIds');
      for( var i = 0; i < partsIds.length; i++ ){
        var id = partsIds[i];

        if( id === participantId ){
          return true;
        }
      }

      return false;
    },

    popoverIsOpen: function(){
      return popoversOpen;
    },

    closeAllPopovers: function(){
      popoversOpen = false;

      if( model.get('_showTextmining') ){
        model.set('_showTextmining', false);
      }

      var ents = model.get('_entities');
      for( var i = 0; i < ents.length; i++ ){
        ent = ents[i];

        if( ent._showAddParticipants ){ // must do selectively like this to prevent many model updates
          model.set('_entities.' + i + '._showAddParticipants', false);
        }

        if( ent._showEdit ){
          model.set('_entities.' + i + '._showEdit', false);
        }

      }
    },

    populatePotentialParticipantsForAllOpen: function(){
      var ents = model.get('_entities');

      for( var i = 0; i < ents.length; i++ ){
        var ent = ents[i];

        if( ent._showAddParticipants ){
          doc.populatePotentialParticipants( ent.id );
        }
      }
    },

    populatePotentialParticipants: function( interactionId ){
      var havePart = {};
      var pots = [];

      var partIds = model.get('entities.' + interactionId + '.participantIds');
      for( var i = 0; i < partIds.length; i++ ){
        havePart[ partIds[i] ] = true;
      }

      var ents = model.get('_entities');
      for( var i = 0; i < ents.length; i++ ){
        var ent = ents[i];
        var isInt = ent.interaction;
        var hasIntAsPart = false;
        var isSelf = interactionId === ent.id;

        if( !havePart[ ent.id ] && !isSelf ){
          if( isInt ){
            for( var j = 0; j < ent.participantIds.length; j++ ){
              var pid = ent.participantIds[ j ];

              if( pid === interactionId ){
                hasIntAsPart = true;
                break;
              }
            } // for
          }

          if( !isInt || !hasIntAsPart ){
            pots.push( ent );
          }
        }
      }

      model.set('entities.' + interactionId + '._potentialParticipants', pots);
    },

    toggleAddParticipants: function( interactionId, next ){
      togglePopover( model.at('entities').at(interactionId), '_showAddParticipants', '_showAddParticipantsAnimated', function(shown){
        if( shown ){
          doc.populatePotentialParticipants( interactionId );
        }

        next && next( shown );
      } );
    },

    disassociateEntity: function( entityId ){

    },

    entityWithAssociationAlreadyExists: function(db, dbId){
      var entities = model.get('_entities');

      for( var i = 0; i < entities.length; i++ ){
        var ent = entities[i];

        if( ent.association && ent.association.dbId === dbId && ent.association.db === db ){
          console.log(ent.association);
          console.log(db, dbId);
          return true;
        }
      }

      return false;
    },

    // NB: listener has format function( entityId, associationObj ){}
    associateEntityWithPotentialAtIndex: function( entityId, index ){
      var fn = arguments[0];

      if( isFunction(fn) ){
        model.on('set', 'entities.*.association', function(id, assoc){
          fn( id, assoc );
        });

        return;
      }

      var mEntity = model.at('entities').at(entityId);
      var assoc = mEntity.get('_potentialAssociations.' + index);
      
      if( doc.entityWithAssociationAlreadyExists(assoc.db, assoc.dbId) ){
        mEntity.set('_potentialAssociations.' + index + '._alreadyExists', true);
        return;
      } 

      // the association only contains necessary fields s.t.
      // _populatedAssociation can be made from a textmining service call
      mEntity.set('association', {
        db: assoc.db,
        dbId: assoc.dbId,
        organismId: assoc.organismId
      });

      // give access to the full assoc data s.t. the ui can use it
      mEntity.set('_associatedInfo', assoc); 
      mEntity.set('name', assoc.name);

      var index;
      var ents = model.get('_entities');
      for( var i = 0; i < ents.length; i++ ){
        if( ents[i].id === entityId ){
          index = i;
          break;
        }
      }

      if( ents.length !== 1 ){
        mEntity.set('_movingDown', true);
        setTimeout(function(){
          mEntity.set('_movingDown', false);
          model.move('_entities', index, ents.length - 1);
        }, 250);
      }
    },

    entityAssociatedInfoIsLoaded: function( entityId ){
      return model.get('entities.' + entityId + '._associatedInfo') ? true : false;
    },

    loadAssociatedInfoForEntity: function( entityId, next ){
      var mEntity = model.at('entities').at(entityId);
      var assoc = mEntity.get('association');

      var alreadyLoading = mEntity.get('_loadingAssociatedInfo');
      var alreadyLoaded = mEntity.get('_associatedInfo');
      var shouldLoad = assoc && !alreadyLoading && !alreadyLoaded;

      if( shouldLoad ){
        mEntity.set('_loadingAssociatedInfo', true);

        services.getEntityInfo(assoc, function(err, info){
          mEntity.set('_associatedInfo', info);
          mEntity.set('_loadingAssociatedInfo', false);

          isFunction(next) && next();
        }); 
      }

    },

    // sets the list of potential associations for an entity
    // (you should get a list of associations from webservices)
    //
    // example association : { name: 'PCNA', fullName: 'Proliferating...', db: 'uniprot', dbId: 'P12004', organismName: 'homo sapiens', ... }
    setPotentialAssociationsForEntity: function( entityId, associations ){
      // set the index for each association s.t. we can use it in the UI templates
      for( var i = 0; associations && i < associations.length; i++ ){
        associations[i].index = i;
      }

      model.set('entities.' + entityId + '._potentialAssociations', associations);
    },

    entityHasPotentialAssociations: function( entityId ){
      return model.get('entities.' + entityId + '._potentialAssociations') ? true : false;
    },

    getAssociatedEntitiesFromQuery: function(entityId, query, ok ){
      var thisChangeTime = lastAssociationQueryTime = +new Date; // time in unix epoch
      var mEnt = model.at('entities').at(entityId);

      if( !query || query.match(/$\s*^/) ){
        mEnt.set('_potentialAssociations', []);
        mEnt.set('_loadingPotentialAssociations', false);
        return;
      }

      mEnt.set('_loadingPotentialAssociations', true);
      services.getAssociatedEntitiesFromQuery(query, function(err, entities){
        var thisQueryIsTheLatestOne = thisChangeTime >= lastAssociationQueryTime;

        if( thisQueryIsTheLatestOne ){
          mEnt.set('_loadingPotentialAssociations', false);

          doc.setPotentialAssociationsForEntity( entityId, entities );
        }
      });
    },

    toggleEditRevisedNext: function( entityId, actualNext ){
      return function( shown ){
        var mEnt = model.at('entities').at(entityId);
        var name = mEnt.get('name');
        var isInt = mEnt.get('interaction');
        var changedName = mEnt.get('changedName');
        var assoc = mEnt.get('association');
        var potAssocs = mEnt.get('_potentialAssociations');
        var noPotAssocs = potAssocs == null || potAssocs.length === 0;

        if( shown && !isInt && changedName && noPotAssocs ){
          doc.getAssociatedEntitiesFromQuery( entityId, name );
        }

        if( shown && assoc && !doc.entityAssociatedInfoIsLoaded(entityId) ){
          doc.loadAssociatedInfoForEntity( entityId );
        }

        actualNext && actualNext( shown );
      };
    },

    toggleEdit: function( entityId, next ){
      next = doc.toggleEditRevisedNext( entityId, next );
      
      togglePopover( model.at('entities').at(entityId), '_showEdit', '_showEditAnimated', next );
    },

    showEdit: function( entityId, next ){
      next = doc.toggleEditRevisedNext( entityId, next );

      var shown =  model.at('entities').at(entityId).get('_showEdit');

      if( shown ){
        next && next( true );
      } else {
        togglePopover( model.at('entities').at(entityId), '_showEdit', '_showEditAnimated', next );
      }
    },

    showEditForLastAdded: function( next ){
      var entityId = model.get('_entities.0.id');
      next = doc.toggleEditRevisedNext( entityId, next );

      var shown =  model.at('entities').at(entityId).get('_showEdit');

      if( shown ){
        next && next( true );
      } else {
        togglePopover( model.at('entities').at(entityId), '_showEdit', '_noAnimationPlease', next );
      }
    },

    getLastAddedEntity: function(){
      return model.get('_entities.0');
    },




    // FUNCTIONS FOR PRIVATE MODELS //
    // not stored in the db, created fresh each page load, and mostly useful for ui

    toggleTextmining: function( next ){
      togglePopover( model, '_showTextmining', '_showTextminingAnimated', next );
    },

    // uses textmining to add entities to the document
    addEntitiesFromText: function(text, posFn, next){
      services.getPotentialEntitiesFromText(text, function(err, ents){

        // using this textmining function gives temporary integer ids we
        // need to replace
        ents = replaceTempIds( ents );
        ents = makeEntities( ents );

        // add ent's
        for( var i = 0; i < ents.length; i++ ){
          var ent = ents[i];

          if( posFn ){ // if specified, use the position function to place the entity
            ent.viewport = posFn();
          }

          // b/c the textmining "set" the name for the user
          ent.changedName = true;

          doc.addEntity( ent );
        }

        // update participants list for int'ns
        for( var i = 0; i < ents.length; i++ ){
          var ent = ents[i];

          if( ent.interaction ){
            doc.updateParticipantsList( ent.id );
          }
        }
        
        next( ents.length );
      });
    },

    
    exportAsSif: function(){
      var bb = new BlobBuilder;
      
      var inters = model.filter('_entities').where('interaction').equals(true).get();
      for( var i = 0, inter; i < inters.length && (inter = inters[i]); i++ ){
        var pids = inter.participantIds;
        var type = inter.type;

        for( var j = 0, pid; j < pids.length && (pid = pids[j]); j++ ){
          var name = model.at('entities').at(pid).at('name').get();
          bb.append(name);

          if( j === 0 ){
            bb.append('\t' + type + '\t');
          }

          if( j !== pids.length - 1 ){
            bb.append('\t');
          }
        }

        bb.append('\n');
      }

      saveAs(bb.getBlob("text/plain;charset=utf-8"), "factoid.sif");
    }

  };
};