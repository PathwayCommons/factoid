// functions that are exposed to the client side
module.exports = function( model ){

  var EventEmitter = require('events').EventEmitter;

  /* doc schema:

    document: {
      elements: [
        {
          id: "ent1", // ids are actually just unique junk strings generated by derby
          type: "entity", // indicates the type of entity
          name: "some entity" // user specified name
        },

        {
          id: "int1",
          type: "interaction",
          name: "some interaction",
          participantIds: [ "ent1", "ent2" ] // what participants are connected
        }
      ]
    }

  */

  function isFunction( obj ){
    return typeof obj === "function";
  }

  // keep the `_entities` ref up-to-date so we can use it in the api below
  model.subscribe('_doc.entities', function (err, entities) {
    model.ref('_entities', "_doc.entities");
  });

  // TODO make an emitter per document or figure out how to listen to complex
  // model events (preferable)
  var emitter = new EventEmitter();

  return {

    // NB: you should listen via addEntity (not addInteraction)
    // otherwise, you'd have to negotiate and merge multiple events (pretty hard)
    addInteraction: function( interaction ){
      if( interaction.type !== "interaction" ){ // enforce interaction type
        interaction.type = "interaction";
      }

      if( !interaction.name ){
        interaction.name = "new interaction";
      }

      interaction.participantIds = [];

      return this.addEntity(interaction);
    },

    // TODO document
    addEntity: function( entity ){
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is added to the doc
        emitter.on("addEntity", fn);
        return;

      } else { // then add the entity to the doc
        if( !entity ){ // in case nothing specified
          entity = {};
        }

        if( !entity.type ){ // in case type is elided
          entity.type = "entity";
        }

        if( !entity.name ){ // in case name is elided, use some default value
          entity.name = "new entity";
        }

        if( entity.id === undefined ){ // then generate an id for the entity
          entity.id = model.id(); 
        }

        model.push( "_entities", entity );
        emitter.emit("addEntity", entity); // notify listeners
      }

      return entity.id;
    },

    // TODO document
    removeEntity: function( entityId ){
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is removed from the doc
        emitter.on("removeEntity", fn);
        return;

      } else { // then remove the entity from the doc
        var entities = model.get("_entities");
        for( var i = 0; i < entities.length; i++ ){ // find entity
          var entity = entities[i];
          var entityMatches = entity.id === entityId;
          
          if( entityMatches ){ // then remove the element
            model.remove(path, i, 1);
            emitter.emit("removeEntity", entityId);
            break;
          }
        } // for
      } // else
    },

    // .connectEntityToInteraction(intId, entId) : connects entity to interaction
    // fails when
    //  - entity and interaction are the same
    //  - entity or interaction aren't in the document
    //  - entity is already connected to interaction
    //  - the interaction specified isn't actually one
    //
    // .connectEntityToInteraction()
    connectEntityToInteraction: function( entityId, interactionId ){
      var intIndex, entIndex, interaction, entity;
      var fn = arguments[0];

      if( isFunction(fn) ){ // then listen to when entities are connected to interactions
        emitter.on("connectEntityToInteraction", entityId, interactionId);
        return;
      }

      if( interactionId === entityId ){
        return; // you can't connect an interaction to itself
      }

      var entities = model.get("_entities");
      for( var i = 0; i < entities.length; i++ ){
        var enti = entities[i];

        switch( enti.id ){
        case entityId:
          entIndex = i;
          entity = enti;
          break;

        case interactionId:
          intIndex = i;
          interaction = enti;
          break;
        }
      }

      var inDoc = intIndex !== undefined && entIndex !== undefined;
      var interactionIsRightType = interaction.type === 'interaction;'
      if( !inDoc ){
        return; // you can't connect them together if they don't exist in the doc
      }

      // check if the entity is already connected
      var pids = interaction.participantIds;
      var entityAlreadyConnected = false;
      for( var i = 0; i < pids.length; i++ ){
        var pid = pids[i];

        entityAlreadyConnected = pid === entityId;
        if( entityAlreadyConnected ){ break; } // don't need to check anymore if already connected
      }

      if( !entityAlreadyConnected ){
        model.push('_entities.' + intIndex + '.participantIds', entityId);
        emitter.emit('connectEntityToInteraction', entityId, interactionId);
      }

    },

    // TODO document
    entityName: function( entityId, name ){
      var fn = entityId
    }


  };
};