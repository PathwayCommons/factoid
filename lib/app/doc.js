// the document controller (used to modify a currently-loaded document)

// functions that are exposed to the client side
module.exports = function( model ){

  /* doc schema:

    document: {
      elements: [
        {
          id: "ent1", // ids are actually just unique junk strings generated by derby
          type: "entity", // indicates the type of entity
          name: "some entity" // user specified name
        },

        {
          id: "int1",
          type: "interaction",
          name: "some interaction",
          participantIds: [ "ent1", "ent2" ] // what participants are connected
        }
      ]
    }
  */

  function isFunction( obj ){
    return typeof obj === "function";
  }

  function isObject( obj ){
    return typeof obj === 'object';
  }

  return {

    // FUNCTIONS FOR PUBLIC MODELS //
    // stored in the db and synced to clients

    // .addInteraction({ [type], [name] })
    // adds an interaction to the doc
    // NB: you should listen via addEntity (not addInteraction)
    // otherwise, you'd have to negotiate and merge multiple events (pretty hard)
    addInteraction: function( interaction ){
      interaction = interaction || {}; // ensure we have an object

      if( interaction.type !== "interaction" ){ // enforce interaction type
        interaction.type = "interaction";
      }

      if( !interaction.name ){
        interaction.name = "new interaction";
      }

      interaction.participantIds = [];
      interaction.interaction = true;

      return this.addEntity(interaction);
    },

    // .addEntity({ [type], [name], [viewport] })
    // add an entity to the document
    // 
    // .addEntity( function( entity ){} )
    // listen for when entities are added
    addEntity: function( entity ){
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is added to the doc
        model.on('push', '_entities', function(entity, index, isLocal){
          fn( entity );
        });
        return;

      } else { // then add the entity to the doc
        if( !entity ){ // in case nothing specified
          entity = {};
        }

        if( !entity.type ){ // in case type is elided
          entity.type = "entity";
        }

        if( !entity.name ){ // in case name is elided, use some default value
          entity.name = "new entity";
        }

        entity.entity = true;

        if( !entity.viewport ){
          entity.viewport = {
            x: 0,
            y: 0
          };
        }

        if( entity.id === undefined ){ // then generate an id for the entity
          entity.id = model.id();
        }

        var entityWithSameIdAlreadyExists = this.entity(entity.id) !== undefined;
        if( entityWithSameIdAlreadyExists ){
          return; // there can only be one
        }

        model.push( "_entities", entity );
      }

      return entity;
    },

    // .removeEntity( entityId )
    // removes the entity from the document
    //
    // .removeEntity( function( entityId ){} )
    // listens for when entities are removed
    removeEntity: function( entityId ){
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is removed from the doc
        model.on('remove', '_entities', function(index, howMany, removedArray, isLocal){
          for( var i = 0; i < removedArray.length; i++ ){
            var removedEnt = removedArray[i];
            var id = removedEnt.id;

            fn(id);
          }
        });
        return;

      } else { // then remove the entity from the doc
        var index = model.at('_entityIdToIndex').get( entityId );
        model.remove('_entities', index);

        var connectedInts = model.filter('_entities').where('participantIds').contains( [entityId] ).get();
        for( var i = 0; i < connectedInts.length; i++ ){
          var inter = connectedInts[i];

          var pids = inter.participantIds;
          for( var j = 0; j < pids.length; j++ ){
            var pid = pids[j];

            if( pid === entityId ){
              model.remove('_entities.' + i + '.participantIds', j);
            }
          }
        }
      }
    },

    // removes all entities from the doc
    // NB: use .removeEntity() for listening to when entities are removed
    removeAllEntities: function(){
      var length = model.get('_entities.length');
      model.remove('_entities', 0, length);
    },

    // .connectEntityToInteraction(entId, intId) : connects entity to interaction
    // fails when
    //  - entity and interaction are the same
    //  - entity or interaction aren't in the document
    //  - entity is already connected to interaction
    //  - the interaction specified isn't actually one
    //
    // .connectEntityToInteraction( function(entId, intId){} ) : listens for when
    // an entity is connected to an interaction
    connectEntityToInteraction: function( entityId, interactionId ){
      var intIndex, entIndex, interaction, entity;
      var fn = arguments[0];

      if( isFunction(fn) ){ // then listen to when entities are connected to interactions
        model.on('push', '_entities.*.participantIds', function(intIndex, entityId){
          var interactionId = model.get('_entities.' + intIndex + '.id');
          fn(entityId, interactionId);
        });
        return;
      }

      if( interactionId === entityId ){
        return; // you can't connect an interaction to itself
      }

      var entityExists = this.entityExists( entityId );
      var interactionExists = this.entityExists( interactionId );

      var inDoc = entityExists && interactionExists;
      if( !inDoc ){
        return; // you can't connect them together if they don't exist in the doc
      }
      var interaction = this.entity( interactionId );
      var interactionIsRightType = interaction.interaction;
      if( !interactionIsRightType ){ return; } // can't connect if not right type

      // check if the entity is already connected
      var entityAlreadyConnected = this.interactionHasParticipant( interactionId, entityId );
      if( entityAlreadyConnected ){ return; } // can't connect if already connected

      var intIndex = model.get('_entityIdToIndex.' + interactionId);
      model.push('_entities.' + intIndex + '.participantIds', entityId);

    },

    // .disconnectEntityFromInteraction( entId, intId ) : disconnected an entity from an
    // interaction; can fail if they're not connected to begin with
    //
    // .disconnectEntityFromInteraction( function(entId, intId){} ) : listens for when an
    // entity is disconnected from an interaction
    disconnectEntityFromInteraction: function( entityId, interactionId ){
      var fn = arguments[0];

      if( isFunction(fn) ){ // then listen to when entities are disconnected to interactions
        model.on('remove', '_entities.*.participantIds', function(intIndex, index, howMany, removedArray, isLocal){
          var interactionId = model.get('_entities.' + intIndex + '.id');
          for( var i = 0; i < removedArray.length; i++ ){
            var entityId = removedArray[i];

            fn(entityId, interactionId);
          }         
          
        });
        return;
      }

      var entity = this.entity(entityId);
      var interaction = this.entity(interactionId);
      var intIndex = model.get('_entityIdToIndex.' + interactionId);

      var inDoc = entity && interaction;
      var interactionIsRightType = interaction.type === 'interaction;'
      if( !inDoc ){
        return; // you can't connect them together if they don't exist in the doc
      }

      // check if the entity is already connected
      var entityAlreadyConnected = false;
      var pids = interaction.participantIds;
      var entIndex;
      for( var i = 0; i < pids.length; i++ ){
        var pid = pids[i];

        if( pid === entityId ){
          entityAlreadyConnected = true;
          entIndex = i;
          break;
        }
      }

      if( entityAlreadyConnected ){
        model.remove('_entities.' + intIndex + '.participantIds', entIndex, 1);
      }
    },

    // .entityName( entId ) : gets the current entity name
    //
    // .entityName( entId, newName ) : sets the entity's name to a new one
    //
    // .entityName( function(entId, name){} ) : listens for when an entity's name is changed
    entityName: function( entityId, name ){
      var fn = arguments[0];
    
      if( isFunction(fn) ){
        model.on('set', '_entities.*.name', function(index, newName, oldName, isLocal){
          var entityId = model.get('_entities.' + index + '.id');
          fn( entityId, newName );
        });

      } else if( name === undefined ) {
        var index = model.get('_entityIdToIndex.' + entityId);
        return model.get('_entities.' + index + '.name');

      } else {
        var index = model.get('_entityIdToIndex.' + entityId);
        model.set('_entities.' + index + '.name', name);
      }
    },

    // NB: the viewport position of the entity is just the model position of the associated node
    // in cytoscape.js but the format could be made more complex to accomodate more info later, if needed
    //
    // .entityViewport( entId ) : gets the current viewport position of the entity
    // 
    // .entityViewport( entId, viewport ) : sets the current viewport position of the entity
    // 
    // .entityViewport( function(entId, viewport){} ) : listens for when an entity's viewport changes
    entityViewport: function( entityId, viewport ){
      var fn = arguments[0];

      if( isFunction(fn) ){
        model.on('set', '_entities.*.viewport', function(index, newPos, oldPos, isLocal){

          if( isLocal ){ return; } // don't trigger if we moved it (since we're already up-to-date)

          if( newPos.x === undefined || newPos.y === undefined ){
            return; // can't really do anything :(
          }

          var id = model.get('_entities.' + index + '.id');
          fn(id, newPos);
        });

      } else if( viewport === undefined ) {
        var index = model.get('_entityIdToIndex.' + entityId);
        return model.get('_entities.' + index + '.viewport');
      
      } else {
        var index = model.get('_entityIdToIndex.' + entityId);
        model.set('_entities.' + index + '.viewport', viewport);
      }
    },

    // .entity( entId ) : gets the entity with the given id
    // 
    // NB: you shouldn't really need to call this, especially considering that the
    // entity object you get here isn't populated with all the convenient stuff
    // you'd need to build UI, anyway
    entity: function( entityId ){
      var index = model.get('_entityIdToIndex.' + entityId);
      return model.get('_entities.' + index);
    },

    // checks whether an entity with the specified ID exists in the document
    entityExists: function( entityId ){
      return this.entity( entityId ) !== undefined;
    },

    // checks whether an entity with the specified ID exists in the document
    entityIsInteraction: function( entityId ){
      return this.entity( entityId ).interaction ? true : false;
    },

    // gets all the entities in the document (useful for populating cytoscape.js graph on page load)
    entities: function(){
      return model.get('_entities');
    },

    // TODO not used so can we just delete this?
    interactionParticipants: function( interactionId ){
      var index = model.get('_entityIdToIndex.' + interactionId);
      return model.get('_populatedEntities.' + index + '.participants');
    },

    // gets whether an interaction has a participant
    interactionHasParticipant: function( interactionId, participantId ){
      var intIndex = model.get('_entityIdToIndex.' + interactionId);
      var partsIds = model.get('_entities.' + intIndex + '.participantIds');
      for( var i = 0; i < partsIds.length; i++ ){
        var id = partsIds[i];

        if( id === participantId ){
          return true;
        }
      }

      return false;
    },

    // .associateEntity( entId, db, dbId ) : associates the entity with the given
    // database (e.g. db="uniprot") and the given database ID (e.g. dbId="P12004" for PCNA-HUMAN)
    //
    // .associateEntity( entId, db, dbId, name ) : associates the entity with the
    // specified database entry and sets the entity name to the name in the database
    // (you'll need to specify the name manually)
    //
    // .associateEntity( function(entId, db, dbId){} ) : listens to when an entity
    // is associated with a db (NB you don't get the name in the listener)
    associateEntity: function( entityId, db, dbId, name ){
      var fn = arguments[0];

      if( isFunction(fn) ){
        model.on('set', '_entities.*.association', function(index, assoc){
          var id = model.get('_entities.' + index + '.id');
          fn( id, assoc.db, assoc.id );
        });

      } else {
        var index = model.get('_entityIdToIndex.' + entityId);
        model.set('_entities.' + index + '.association', {
          db: db,
          id: dbId
        });

        if( name ){
          doc.entityName( entityId, name );
        }
      }
    },

    // sets the list of potential associations for an entity
    // (you should get a list of associations from webservices)
    //
    // example association : { name: 'PCNA', fullName: 'Proliferating...', db: 'uniprot', dbId: 'P12004', organismName: 'homo sapiens', ... }
    setPotentialAssociationsForEntity: function( entityId, associations ){
      model.set('_potentialAssociationsFor.' + entityId, associations);
    },




    // FUNCTIONS FOR PRIVATE MODELS //
    // not stored in the db, created fresh each page load, and mostly useful for ui

    // sets the text we want to mine for entities & interactions; `next` is called
    // with the results like next(error, entities)
    setTextminingText: function(text, next){
      model.set('_textminingText', text);

      textmining.getPotentialEntitiesFromText(text, function(err, ents){
        doc.setTextminingEntities( ents );
        next();
      });
    },

    // sets the list of potential entities that the user can choose from as
    // textmining results
    setTextminingEntities: function( entities ){
      if( entities ){
        for( var i = 0; i < entities.length; i++ ){
          var ent = entities[i];

          ent.id = model.id();
        }

         model.set('_textminingEntities', entities);
      }
     
    },

    // remove all the textmining entities so we start fresh again
    removeAllTextminingEntities: function(){
      model.del('_textminingEntities');
    },

    // removes a particular entity from the list of textmining entites (that the
    // user can choose from to add to the doc)
    removeTextminingEntity: function( entityId ){
      var entities = model.get('_textminingEntities') || [];
      for( var i = 0; i < entities.length; i++ ){
        var ent = entities[i];

        if( ent.id === entityId ){
          model.remove('_textminingEntities', i);
          return;
        }
      }
    },

    // adds whatever textmining entities we currently have to the document
    addCurrentTextminingEntities: function( posFn ){
      var entities = model.get('_textminingEntities') || [];
      model.set('_textminingEntities', []);
      model.set('_textminingText');

      for( var i = 0; i < entities.length; i++ ){
        var ent = entities[i];

        if( posFn ){ // if specified, use the position function to place the entity
          ent.viewport = posFn();
        }

        doc.addEntity( ent );
      }
    }

  };
};