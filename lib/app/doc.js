// functions that are exposed to the client side
module.exports = function( model ){

  var EventEmitter = require('events').EventEmitter;

  /* doc schema:

    document: {
      elements: [
        {
          id: "ent1", // ids are actually just unique junk strings generated by derby
          type: "entity", // indicates the type of entity
          name: "some entity" // user specified name
        },

        {
          id: "int1",
          type: "interaction",
          name: "some interaction",
          participantIds: [ "ent1", "ent2" ] // what participants are connected
        }
      ]
    }
  */

  function isFunction( obj ){
    return typeof obj === "function";
  }

  function isObject( obj ){
    return typeof obj === 'object';
  }

  function getEntityIndex( entityId ){
    var id2index = model.get('_entityIdToIndex');
    return id2index[ entityId ];
  }

  function getEntityId( entityOrId ){
    if( isObject(entityOrId) ){
      var entity = entityOrId;
      return entity.id;
    } else {
      var id = entityOrId;
      return id;
    }
  }

  // TODO make an emitter per document or figure out how to listen to complex
  // model events (preferable)
  var emitter = new EventEmitter();

  return {

    // NB: you should listen via addEntity (not addInteraction)
    // otherwise, you'd have to negotiate and merge multiple events (pretty hard)
    addInteraction: function( interaction ){
      interaction = interaction || {}; // ensure we have an object

      if( interaction.type !== "interaction" ){ // enforce interaction type
        interaction.type = "interaction";
      }

      if( !interaction.name ){
        interaction.name = "new interaction";
      }

      interaction.participantIds = [];
      interaction.interaction = true;

      return this.addEntity(interaction);
    },

    // TODO document
    addEntity: function( entity ){
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is added to the doc
        model.on('push', '_entities', function(entity, index, isLocal){
          fn( entity, isLocal );
        });
        return;

      } else { // then add the entity to the doc
        if( !entity ){ // in case nothing specified
          entity = {};
        }

        if( !entity.type ){ // in case type is elided
          entity.type = "entity";
        }

        if( !entity.name ){ // in case name is elided, use some default value
          entity.name = "new entity";
        }

        entity.entity = true;

        if( !entity.viewport ){
          entity.viewport = {
            x: 0,
            y: 0
          };
        }

        if( entity.id === undefined ){ // then generate an id for the entity
          entity.id = model.id(); 
        }

        var index = model.push( "_entities", entity ) - 1;
        model.set('_entityIdToIndex.' + entity.id, index);
      }

      return entity.id;
    },

    // TODO document
    removeEntity: function( entityId ){
      var fn = arguments[0];
      if( isFunction( fn ) ){ // then bind to when an entity is removed from the doc
        model.on('del', '_entityIdToIndex.*', function(id, junk, isLocal){
          fn( id, isLocal );
        });
        return;

      } else { // then remove the entity from the doc
        var index = getEntityIndex( entityId );
        model.remove('_entities', index, 1);
        model.del('_entityIdToIndex.' + entityId);

        // update indices
        var entities = this.entities();
        for( var i = index; i < entities.length; i++ ){
          var ent = entities[i];
          model.set('_entityIdToIndex.' + ent.id, i);
        }

        // remove references in interactions
        var entities = this.entities();
        for( var i = 0; i < entities.length; i++ ){
          var ent = entities[i];

          if( ent.interaction ){
            var pids = ent.participantIds;
            for( var j = 0; j < pids.length; j++ ){
              var pid = pids[j];

              if( pid === entityId ){
                model.remove('_entities.' + i + 'participantIds', j, 1);
                break;
              }
            } // for j
          } // if
        } // for i
      } // else
    },

    // .connectEntityToInteraction(intId, entId) : connects entity to interaction
    // fails when
    //  - entity and interaction are the same
    //  - entity or interaction aren't in the document
    //  - entity is already connected to interaction
    //  - the interaction specified isn't actually one
    //
    // .connectEntityToInteraction()
    connectEntityToInteraction: function( entityId, interactionId ){
      var intIndex, entIndex, interaction, entity;
      var fn = arguments[0];

      if( isFunction(fn) ){ // then listen to when entities are connected to interactions
        model.on('push', '_entities.*.participantIds', function(intIndex, entityId){
          var interactionId = model.get('_entities.' + intIndex + '.id');
          fn(entityId, interactionId);
        });
        return;
      }

      if( interactionId === entityId ){
        return; // you can't connect an interaction to itself
      }

      var entity = this.entity(entityId);
      var interaction = this.entity(interactionId);
      var intIndex = this.entityIndex(interactionId);

      var inDoc = entity && interaction;
      var interactionIsRightType = interaction.type === 'interaction;'
      if( !inDoc ){
        return; // you can't connect them together if they don't exist in the doc
      }

      // check if the entity is already connected
      var entityAlreadyConnected = this.interactionHasParticipant( interactionId, entityId );

      if( !entityAlreadyConnected ){
        model.push('_entities.' + intIndex + '.participantIds', entityId);
      }

    },

    disconnectEntityFromInteraction: function( entityId, interactionId ){
      var fn = arguments[0];

      if( isFunction(fn) ){ // then listen to when entities are disconnected to interactions
        model.on('remove', '_entities.*.participantIds', function(intIndex, index, howMany, array){
          entityId = array[index];
          var interactionId = model.get('_entities.' + intIndex + '.id');
          fn(entityId, interactionId);
        });
        return;
      }

      var entity = this.entity(entityId);
      var interaction = this.entity(interactionId);
      var intIndex = this.entityIndex(interactionId);

      var inDoc = entity && interaction;
      var interactionIsRightType = interaction.type === 'interaction;'
      if( !inDoc ){
        return; // you can't connect them together if they don't exist in the doc
      }

      // check if the entity is already connected
      var entityAlreadyConnected = false;
      var pids = interaction.participantIds;
      var entIndex;
      for( var i = 0; i < pids.length; i++ ){
        var pid = pids[i];

        if( pid === entityId ){
          entityAlreadyConnected = true;
          entIndex = i;
          break;
        }
      }

      if( entityAlreadyConnected ){
        model.remove('_entities.' + intIndex + '.participantIds', entIndex, 1);
      }
    },

    // TODO document
    entityName: function( entityId, name ){
      var fn = arguments[0];
      

      if( isFunction(fn) ){
        var entityId = name;

        if( entityId === undefined ){
          model.on('set', '_entities.*.name', function(index, newName, oldName, isLocal){
            fn( model.get('_entities.' + index + '.id'), newName );
          });
        } else {
          var index = getEntityIndex(entityId);
          model.on('set', '_entities.' + index + '.name', function(newName){
            fn(entityId, newName);
          });
        }

      } else if( name === undefined ) {
        var index = getEntityIndex(entityId);
        return model.get('_entities.' + index + '.name');

      } else {
        var index = getEntityIndex(entityId);
        model.set('_entities.' + index + '.name', name);
      }
    },

    entityViewport: function( entityId, viewport ){
      var fn = arguments[0];

      if( isFunction(fn) ){
        model.on('set', '_entities.*.viewport', function(index, oldPos, newPos, isLocal){

          if( isLocal ){ return; } // don't trigger if we moved it (since we're already up-to-date)

          if( newPos.x === undefined || newPos.y === undefined ){
            newPos = oldPos;
          }

          var id = model.get('_entities.' + index + '.id');
          fn(id, newPos);
        });

      } else if( viewport === undefined ) {
        return model.get('_entities.' + getEntityIndex(entityId) + '.viewport');
      
      } else {
        model.set('_entities.' + getEntityIndex(entityId) + '.viewport', viewport);
      }
    },

    entityIndex: function( entityId ){
      return model.get('_entityIdToIndex.' + entityId);
    },

    entity: function( entityId ){
      var index = this.entityIndex( entityId );
      return model.get('_entities.' + index);
    },

    entities: function(){
      return model.get('_entities');
    },

    interactionParticipantIds: function( interactionId ){
      return this.entity( interactionId ).participantIds;      
    },

    interactionHasParticipant: function( interactionId, participantId ){
      var partsIds = this.interactionParticipantIds(interactionId);
      for( var i = 0; i < partsIds.length; i++ ){
        var id = partsIds[i];

        if( id === participantId ){
          return true;
        }
      }

      return false;
    }

  };
};