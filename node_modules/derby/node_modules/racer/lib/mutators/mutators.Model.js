// Generated by CoffeeScript 1.3.1
var ACCESSOR, ARRAY_MUTATOR, Async, BASIC_MUTATOR, COMPOUND_MUTATOR, Memory,
  __slice = [].slice;

Async = require('./Async');

Memory = require('../Memory');

module.exports = {
  type: 'Model',
  "static": {
    ACCESSOR: ACCESSOR = 'accessor',
    BASIC_MUTATOR: BASIC_MUTATOR = 'mutator,basicMutator',
    COMPOUND_MUTATOR: COMPOUND_MUTATOR = 'mutator,compoundMutator',
    ARRAY_MUTATOR: ARRAY_MUTATOR = 'mutator,arrayMutator'
  },
  events: {
    init: function(model) {
      var memory;
      memory = new Memory;
      return model.async = new Async({
        nextTxnId: function() {
          return model._nextTxnId();
        },
        get: function(path, callback) {
          return model._waitOrFetchData([path], function(err, data) {
            var item, items, len, out, subpath, value, _i, _len, _ref;
            if (err) {
              return callback(err);
            }
            if (!((items = data.data) && (len = items.length))) {
              return callback();
            }
            if (len === 1 && (item = items[0]) && item[0] === path) {
              return callback(null, item[1]);
            }
            for (_i = 0, _len = items.length; _i < _len; _i++) {
              _ref = items[_i], subpath = _ref[0], value = _ref[1];
              memory.set(subpath, value, -1);
            }
            out = memory.get(path);
            memory.flush();
            return callback(null, out);
          });
        },
        commit: function(txn, callback) {
          return model._asyncCommit(txn, callback);
        }
      });
    }
  },
  proto: {
    get: {
      type: ACCESSOR,
      fn: function(path) {
        var at;
        if (at = this._at) {
          path = path ? at + '.' + path : at;
        }
        return this._memory.get(path, this._specModel());
      }
    },
    set: {
      type: BASIC_MUTATOR,
      fn: function(path, value, callback) {
        var at, len;
        if (at = this._at) {
          len = arguments.length;
          path = len === 1 || len === 2 && typeof value === 'function' ? (callback = value, value = path, at) : at + '.' + path;
        }
        return this._addOpAsTxn('set', [path, value], callback);
      }
    },
    del: {
      type: BASIC_MUTATOR,
      fn: function(path, callback) {
        var at;
        if (at = this._at) {
          path = typeof path === 'string' ? at + '.' + path : (callback = path, at);
        }
        return this._addOpAsTxn('del', [path], callback);
      }
    },
    add: {
      type: COMPOUND_MUTATOR,
      fn: function(path, value, callback) {
        var id, len;
        id = this.id();
        len = arguments.length;
        if (this._at && len === 1 || len === 2 && typeof value === 'function') {
          callback = value;
          value = path;
          path = id;
        } else {
          path = path + '.' + id;
        }
        if (typeof value !== 'object') {
          throw 'model.add() requires an object argument';
        }
        value.id = id;
        if (callback) {
          this.set(path, value, callback);
        } else {
          this.set(path, value);
        }
        return id;
      }
    },
    setNull: {
      type: COMPOUND_MUTATOR,
      fn: function(path, value, callback) {
        var len, obj;
        len = arguments.length;
        obj = this._at && len === 1 || len === 2 && typeof value === 'function' ? this.get() : this.get(path);
        if (obj != null) {
          return obj;
        }
        if (len === 1) {
          return this.set(path);
        } else if (len === 2) {
          return this.set(path, value);
        } else {
          return this.set(path, value, callback);
        }
      }
    },
    incr: {
      type: COMPOUND_MUTATOR,
      fn: function(path, byNum, callback) {
        var value;
        if (typeof path !== 'string') {
          callback = byNum;
          byNum = path;
          path = '';
        }
        if (typeof byNum === 'function') {
          callback = byNum;
          byNum = 1;
        } else if (typeof byNum !== 'number') {
          byNum = 1;
        }
        value = (this.get(path) || 0) + byNum;
        if (path) {
          this.set(path, value, callback);
          return value;
        }
        if (callback) {
          this.set(value, callback);
        } else {
          this.set(value);
        }
        return value;
      }
    },
    push: {
      type: ARRAY_MUTATOR,
      insertArgs: 1,
      fn: function() {
        var args, at, callback, path;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (at = this._at) {
          if (typeof (path = args[0]) === 'string' && typeof this.get() === 'object') {
            args[0] = at + '.' + path;
          } else {
            args.unshift(at);
          }
        }
        if (typeof args[args.length - 1] === 'function') {
          callback = args.pop();
        }
        return this._addOpAsTxn('push', args, callback);
      }
    },
    unshift: {
      type: ARRAY_MUTATOR,
      insertArgs: 1,
      fn: function() {
        var args, at, callback, path;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (at = this._at) {
          if (typeof (path = args[0]) === 'string' && typeof this.get() === 'object') {
            args[0] = at + '.' + path;
          } else {
            args.unshift(at);
          }
        }
        if (typeof args[args.length - 1] === 'function') {
          callback = args.pop();
        }
        return this._addOpAsTxn('unshift', args, callback);
      }
    },
    insert: {
      type: ARRAY_MUTATOR,
      indexArgs: [1],
      insertArgs: 2,
      fn: function() {
        var args, at, callback, match, path;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (at = this._at) {
          if (typeof (path = args[0]) === 'string' && isNaN(path)) {
            args[0] = at + '.' + path;
          } else {
            args.unshift(at);
          }
        }
        if (match = /^(.*)\.(\d+)$/.exec(args[0])) {
          args[0] = match[1];
          args.splice(1, 0, match[2]);
        }
        if (typeof args[args.length - 1] === 'function') {
          callback = args.pop();
        }
        return this._addOpAsTxn('insert', args, callback);
      }
    },
    pop: {
      type: ARRAY_MUTATOR,
      fn: function(path, callback) {
        var at;
        if (at = this._at) {
          path = typeof path === 'string' ? at + '.' + path : (callback = path, at);
        }
        return this._addOpAsTxn('pop', [path], callback);
      }
    },
    shift: {
      type: ARRAY_MUTATOR,
      fn: function(path, callback) {
        var at;
        if (at = this._at) {
          path = typeof path === 'string' ? at + '.' + path : (callback = path, at);
        }
        return this._addOpAsTxn('shift', [path], callback);
      }
    },
    remove: {
      type: ARRAY_MUTATOR,
      indexArgs: [1],
      fn: function(path, start, howMany, callback) {
        var at, match;
        if (at = this._at) {
          path = typeof path === 'string' && isNaN(path) ? at + '.' + path : (callback = howMany, howMany = start, start = path, at);
        }
        if (match = /^(.*)\.(\d+)$/.exec(path)) {
          callback = howMany;
          howMany = start;
          start = match[2];
          path = match[1];
        }
        if (typeof howMany !== 'number') {
          callback = howMany;
          howMany = 1;
        }
        return this._addOpAsTxn('remove', [path, start, howMany], callback);
      }
    },
    move: {
      type: ARRAY_MUTATOR,
      indexArgs: [1, 2],
      fn: function(path, from, to, howMany, callback) {
        var at, match;
        if (at = this._at) {
          path = typeof path === 'string' && isNaN(path) ? at + '.' + path : (callback = howMany, howMany = to, to = from, from = path, at);
        }
        if (match = /^(.*)\.(\d+)$/.exec(path)) {
          callback = howMany;
          howMany = to;
          to = from;
          from = match[2];
          path = match[1];
        }
        if (typeof howMany !== 'number') {
          callback = howMany;
          howMany = 1;
        }
        return this._addOpAsTxn('move', [path, from, to, howMany], callback);
      }
    }
  }
};
