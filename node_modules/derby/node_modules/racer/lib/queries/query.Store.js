var QueryHub = require('./QueryHub')
  , QueryBuilder = require('./QueryBuilder')
  , path = require('../path')
  , splitPath = path.split
  , lookup = path.lookup
  , finishAfter = require('../util/async').finishAfter
  , queryUtils = require('./util')
  , resultPointerPath = queryUtils.resultPointerPath
  , QueryMotifRegistry = require('./QueryMotifRegistry')
  ;

module.exports = {
  type: 'Store'

, events: {
    init: function (store, opts) {
      store._queryCoordinator = new QueryHub(store);

      // Contains all the registered query motifs defined via store.query.expose
      var registry = store._queryMotifRegistry = new QueryMotifRegistry;

      /**
       * Exposes a parameterized data set equivalent to the result set of a
       * query generated by the `callback`. The parameterized
       * Behind the scenes, this creates a QueryMotif.
       * Query motifs define a set of data equivalent to the result set of a
       * query, and they provide an easy string name reference to this data. This
       * declares and registers a query motif that will subsequently be available
       * from the Store or Model via Store#_queryMotifRegistry and
       * Model#_queryMotifRegistry respectively.
       *
       * @optional @param {String} ns is the namespace of documents over which to
       * query
       * @param {String} motifName is the name of the query motif
       * @param {Function} callback in which we define the query.
       * callback(queryArgs...) returns a QueryBuilder
       * @return {Object} store.query for method chaining
       * @api public
       */
      var chainable = store.query = {
        expose: function (ns, motifName, callback) {
          registry.add(ns, motifName, callback);
          return chainable;
        }
      };
    }
  , socket: function (store, socket, clientId) {
      socket.on('fetch', function (targets, cb) {
        // Only fetch data
        store.fetch(socket, targets, cb);
      });

      socket.on('fetchCurrSnapshot', function (ver, clientStartId, subs) {
        store._onSnapshotRequest(ver, clientStartId, clientId, socket, subs);
      });
    }
  }

, proto: {
    /**
     * Fetches the data represented by targets. The callback is passed {data:
     * data} where data is an Array of triplets of the form [path, datum, ver]
     * meaning to assign datum at version ver to the path inside the fetching
     * model.
     *
     * @param {Socket} socket
     * @param {[String]} targets is an array of strings reprenting
     * paths, path patterns, and/or query motifs.
     * @param {Function} cb is the callback
     * @api private
     */
    fetch: function (socket, targets, cb) {
      var data = []
        , self = this
        , finish = finishAfter(targets.length, function (err) {
            if (err) return cb(err);
            var out = {data: data};
            // Note that `out` may be mutated by ot or other plugins
            self.emit('fetch', out, socket.clientId, targets);
            cb(null, out);
          })
        , session = socket.session;
      for (var i = 0, l = targets.length; i < l; i++) {
        self._fetchSingle(session, targets[i], data, finish);
      }
    }

  /**
   * @param {Object} session of the client doing the fetching. The session is
   * used by _fetchSingle pre middleware for access control
   * @param {String} target
   * @param {Array} data
   * @param {Function} callback
   * @api private
   */
 , _fetchSingle: function (session, target, data, callback) {
      var fetchFn = ('string' === typeof target)
                  ? this._fetchPathData
                  : this._fetchQueryData; // Otherwise, we have an array
      // TODO We need to pass back array of document ids to assign to
      //      queries.someid.resultIds
      fetchFn.call(this, target, function (path, datum, ver) {
        data.push([path, datum, ver]);
      }, callback);
    }

    /**
     * Fetches data associated with a queryTuple [queryMotif, queryArgs...].
     *
     * @param {Array} queryTuple represented as [queryMotif, params...]
     * @param {Function} eachDatumCb is invoked for every matching document
     * @param {Function} finish is invoked after the query results are fetched
     * and after eachDatumCb has been called on every matching document.
     * @api private
     */
  , _fetchQueryData: function (queryTuple, eachDatumCb, finish) {
      var queryJson = this._queryMotifRegistry.queryJSON(queryTuple)
        , queryId = queryTuple[queryTuple.length-1];
      // TODO fetch(queryTuple, ...) ?
      this._queryCoordinator.fetch(queryJson, function (err, result, version) {
        if (err) return finish(err);
        var path;
        if (Array.isArray(result)) {
          var resultIds = [];
          for (var i = 0, l = result.length; i < l; i++) {
            var doc = result[i];
            path = queryJson.from + '.' + doc.id;
            eachDatumCb(path, doc, version);
            resultIds.push(doc.id);
          }

          // '_$queries.<queryId>.resultIds'
          path = resultPointerPath(queryId, queryJson.type);
          eachDatumCb(path, resultIds, version);
        } else if (result) {
          path = queryJson.from + '.' + result.id;
          eachDatumCb(path, result, version);

          // '_$queries.<queryId>.resultId'
          path = resultPointerPath(queryId, queryJson.type);
          eachDatumCb(path, result.id, version);
        }
        finish(null);
      });
    }

    /**
     * Fetches data associated with a path in our data tree.
     *
     * @param {String} path to data that we want to fetch
     * @param {Function} eachDatumCb is invoked for every matching document
     * @param {Function} finish is invoked after the query results are fetched
     * and after eachDatumCb has been called on every matching document.
     * @api private
     */
  , _fetchPathData: function (path, eachDatumCb, finish) {
      var parts = splitPath(path)
        , root = parts[0]
        , remainder = parts[1];
      this.get(root, function (err, datum, ver) {
        if (err) return finish(err);
        if (typeof remainder === 'undefined') {
          eachDatumCb(path, datum, ver);
        } else {
          // The path looks like <root>.*.<remainder>
          // so set each property one level down
          patternMatchingDatum(root, remainder, datum, function (fullPath, datum) {
            eachDatumCb(fullPath, datum, ver);
          });
        }
        return finish(null);
      });
    }

    /**
     * @param {Number} ver is the version
     * @param {} clientStartId
     * @param {String} clientId
     * @param {Socket} socket
     * @param {Array} subs
     * @param {Boolean} shouldSubscribe
     * @api private
     */
  , _onSnapshotRequest: function (ver, clientStartId, clientId, socket, subs, shouldSubscribe) {
      var self = this;
      self._checkVersion(ver, clientStartId, function (err) {
        if (err) return socket.emit('fatalErr', err);
        if (shouldSubscribe) {
          self._pubSub.subscribe(clientId, subs);
        }
        self._mode.snapshotSince({
            ver: ver
          , clientId: clientId
          , subs: subs
        }, function (err, payload) {
          if (err) return socket.emit('fatalErr', err);
          var data = payload.data
            , txns = payload.txns
            , num  = self._txnClock.nextTxnNum(clientId);
          if (data) {
            socket.emit('snapshotUpdate:replace', data, num);
          } else if (txns) {
            var len;
            if (len = txns.length) {
              socket.__Ver = transaction.getVer(txns[len-1]);
            }
            socket.emit('snapshotUpdate:newTxns', txns, num);
          }
        });
      });
    }
  }
};

/**
 * @param {String} prefix is the part of the path up to ".*."
 * @param {String} remainder is the part of the path after ".*."
 * @param {Object} subDoc is the lookup value of the prefix
 * @param {Function} eachDatumCb is the callback for each datum matching the pattern
 * @api private
 */
function patternMatchingDatum (prefix, remainder, subDoc, eachDatumCb) {
  var parts          = splitPath(remainder)
    , appendToPrefix = parts[0]
    , remainder      = parts[1];
  for (var property in subDoc) {
    var value = subDoc[property];
    if (value.constructor !== Object && ! Array.isArray(value)) {
      // We can't lookup `appendToPrefix` on `value` in this case
      continue;
    }
    var newPrefix = prefix + '.' + property + '.' + appendToPrefix
      , newValue = lookup(appendToPrefix, value);
    if (typeof remainder === 'undefined') {
      eachDatumCb(newPrefix, newValue);
    } else {
      patternMatchingDatum(newPrefix, remainder, newValue, eachDatumCb);
    }
  }
}
