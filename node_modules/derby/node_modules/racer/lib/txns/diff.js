// Generated by CoffeeScript 1.3.1
var deepCopy, diffArrays, eventRegExp, lookup, transaction, txnEffect, _ref;

diffArrays = require('../diffMatchPatch').diffArrays;

_ref = require('../path'), eventRegExp = _ref.eventRegExp, lookup = _ref.lookup;

deepCopy = require('../util').deepCopy;

transaction = require('../transaction');

module.exports = {
  txnEffect: txnEffect = function(txn, method, args) {
    var ins, num, rem;
    switch (method) {
      case 'push':
        ins = transaction.getMeta(txn);
        num = args.length - 1;
        break;
      case 'unshift':
        ins = 0;
        num = args.length - 1;
        break;
      case 'insert':
        ins = args[1];
        num = args.length - 2;
        break;
      case 'pop':
        rem = transaction.getMeta(txn);
        num = 1;
        break;
      case 'shift':
        rem = 0;
        num = 1;
        break;
      case 'remove':
        rem = args[1];
        num = args[2];
        break;
      case 'move':
        ins = args[1];
        rem = args[2];
        num = 1;
    }
    return [ins, rem, num];
  },
  mergeTxn: function(txn, txns, txnQueue, arrayMutator, memory, before, after) {
    var afterData, args, argsQ, arr, arrPath, arraySubPath, beforeData, diff, i, id, ins, isArrayMutator, item, match, method, methodQ, num, op, parent, parentPath, patch, patchConcat, path, pathQ, prop, rem, remainder, resetPaths, root, txnQ, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _results;
    path = transaction.getPath(txn);
    method = transaction.getMethod(txn);
    args = transaction.getArgs(txn);
    if (isArrayMutator = arrayMutator[method]) {
      _ref1 = txnEffect(txn, method, args), ins = _ref1[0], rem = _ref1[1], num = _ref1[2];
      arraySubPath = eventRegExp("(" + path + ".(\\d+)).*");
    }
    beforeData = before._data;
    afterData = after._data;
    resetPaths = [];
    patchConcat = [];
    for (_i = 0, _len = txnQueue.length; _i < _len; _i++) {
      id = txnQueue[_i];
      txnQ = txns[id];
      if (txnQ.callback) {
        continue;
      }
      pathQ = transaction.getPath(txnQ);
      if (!transaction.pathConflict(path, pathQ)) {
        continue;
      }
      methodQ = transaction.getMethod(txnQ);
      if (isArrayMutator || arrayMutator[methodQ]) {
        if (!arrPath) {
          if (isArrayMutator) {
            arrPath = path;
          } else {
            arraySubPath = eventRegExp("(" + pathQ + ".\\d+).*");
            if ((match = arraySubPath.exec(path)) && (typeof memory.get(match[1]) === 'object')) {
              continue;
            }
            arrPath = pathQ;
          }
          arr = memory.get(arrPath);
          before.set(arrPath, arr && arr.slice(), 1, beforeData);
          after.set(arrPath, arr && arr.slice(), 1, afterData);
          after[method].apply(after, args.concat(1, afterData));
        }
        argsQ = deepCopy(transaction.getArgs(txnQ));
        if (arraySubPath && (match = arraySubPath.exec(pathQ))) {
          parentPath = match[1];
          i = +match[2];
          if (i >= ins) {
            i += num;
          }
          if (i >= rem) {
            i -= num;
          }
          if (typeof before.get(parentPath) === 'object') {
            resetPaths.push(["" + path + "." + i, match[3]]);
            patchConcat.push({
              method: methodQ,
              args: argsQ
            });
            continue;
          }
        }
        before[methodQ].apply(before, argsQ.concat(1, beforeData));
        after[methodQ].apply(after, argsQ.concat(1, afterData));
      } else {
        txnQ.emitted = false;
      }
    }
    if (arrPath) {
      txn.patch = patch = [];
      diff = diffArrays(before.get(arrPath), after.get(arrPath));
      for (_j = 0, _len1 = diff.length; _j < _len1; _j++) {
        op = diff[_j];
        method = op[0];
        op[0] = arrPath;
        patch.push({
          method: method,
          args: op
        });
      }
      for (_k = 0, _len2 = resetPaths.length; _k < _len2; _k++) {
        _ref2 = resetPaths[_k], root = _ref2[0], remainder = _ref2[1];
        i = remainder.indexOf('.');
        prop = ~i ? remainder.substr(0, i) : remainder;
        if ((parent = after.get(root)) && (prop in parent)) {
          patch.push({
            method: 'set',
            args: ["" + root + "." + remainder, lookup(remainder, parent)]
          });
        } else {
          patch.push({
            method: 'del',
            args: ["" + root + "." + prop]
          });
        }
      }
      _results = [];
      for (_l = 0, _len3 = patchConcat.length; _l < _len3; _l++) {
        item = patchConcat[_l];
        _results.push(patch.push(item));
      }
      return _results;
    }
  }
};
