// Generated by CoffeeScript 1.3.1
var Promise, transaction;

Promise = require('../util/Promise');

transaction = require('../transaction');

module.exports = {
  type: 'Store',
  events: {
    init: function(store) {
      var clientSockets, localModels, nextTxnNum, txnClock;
      clientSockets = store._clientSockets;
      localModels = store._localModels;
      nextTxnNum = {};
      store._txnClock = txnClock = {
        unregister: function(clientId) {
          return delete nextTxnNum[clientId];
        },
        register: function(clientId) {
          return nextTxnNum[clientId] = 1;
        },
        nextTxnNum: function(clientId) {
          if (!(clientId in nextTxnNum)) {
            this.register(clientId);
          }
          return nextTxnNum[clientId]++;
        }
      };
      store._txnBuffers = {};
      return store._pubSub.on('txn', function(clientId, txn) {
        var buffer, model, num, socket, ver;
        if (clientId === transaction.getClientId(txn)) {
          return;
        }
        if (model = localModels[clientId]) {
          return model._onTxn(txn);
        }
        if (socket = clientSockets[clientId]) {
          ver = transaction.getVer(txn);
          if (ver > socket.__ver) {
            socket.__ver = ver;
            num = txnClock.nextTxnNum(clientId);
            return socket.emit('txn', txn, num);
          }
        } else if (buffer = store._txnBuffer(clientId)) {
          return buffer.push(txn);
        }
      });
    },
    socket: function(store, socket, clientId) {
      var txnClock;
      txnClock = store._txnClock;
      socket.__ver = 0;
      socket.on('txn', function(txn, clientStartId) {
        var ver;
        ver = transaction.getVer(txn);
        return store._checkVersion(ver, clientStartId, function(err) {
          if (err) {
            return socket.emit('fatalErr', err);
          }
          return store._commit(txn, function(err) {
            var num, txnId;
            txnId = transaction.getId(txn);
            ver = transaction.getVer(txn);
            if (err && err !== 'duplicate') {
              return socket.emit('txnErr', err, txnId);
            }
            num = txnClock.nextTxnNum(clientId);
            return socket.emit('txnOk', txnId, ver, num);
          });
        });
      });
      socket.on('disconnect', function() {
        delete store._clientSockets[clientId];
        return store._startTxnBuffer(clientId, 3000);
      });
      if (store._txnBuffer(clientId)) {
        store._cancelTxnBufferExpiry(clientId);
        return store._flushTxnBuffer(clientId, socket);
      } else {
        return socket.emit('resyncWithStore', function(subs, clientVer, clientStartId) {
          return store._onSnapshotRequest(clientVer, clientStartId, clientId, socket, subs, 'shouldSubscribe');
        });
      }
    }
  },
  proto: {
    _commit: function(txn, callback) {
      return this._mode.commit(txn, callback);
    },
    _startTxnBuffer: function(clientId, timeoutAfter) {
      var buffer, txnBuffers,
        _this = this;
      if (timeoutAfter == null) {
        timeoutAfter = 3000;
      }
      txnBuffers = this._txnBuffers;
      if (clientId in txnBuffers) {
        console.warn("Already buffering transactions for client " + clientId);
        console.trace();
        return;
      }
      txnBuffers[clientId] = {
        buffer: buffer = [],
        timeout: setTimeout(function() {
          _this.unsubscribe(clientId);
          _this._txnClock.unregister(clientId);
          return delete txnBuffers[clientId];
        }, timeoutAfter)
      };
      return buffer;
    },
    _txnBuffer: function(clientId) {
      var _ref;
      return (_ref = this._txnBuffers[clientId]) != null ? _ref.buffer : void 0;
    },
    _cancelTxnBufferExpiry: function(clientId) {
      return clearTimeout(this._txnBuffers[clientId].timeout);
    },
    _flushTxnBuffer: function(clientId, socket) {
      var txnBuffers, txns;
      txnBuffers = this._txnBuffers;
      txns = txnBuffers[clientId].buffer;
      socket.emit('snapshotUpdate:newTxns', txns);
      return delete txnBuffers[clientId];
    }
  }
};
